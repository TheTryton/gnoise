#pragma once

#include "../noise_generator_module_gpu_code.hpp"

constexpr std::string_view perlin_value_point_1D =
"float perlin_value_point_1D(vec1f v, global float* randoms, global int* generator_defaults, global float* config_f, global int* config_i)\n"
"{\n"
"   float freq = config_f[0];\n"
"   float lac = config_f[1];\n"
"   float pers = config_f[2];\n"
"   int octaveCount = config_i[0];\n"
"   int _seed = config_i[1];\n"
"   float value = 0.0f;\n"
"   float cp = 1.0f;\n"
"   v.x *= freq;\n"
"   for (int i = 0; i < octaveCount; i++)\n"
"   {\n"
"       vec1f nv;\n"
"       nv.x = make_int32_range(v.x);\n"
"       float seed = (_seed + i) & 0xffffffff;\n"
"       float signal = gradient_coherent_noise_1D(nv, seed, randoms, generator_defaults, config_i);\n"
"       value += signal * cp;\n"
"       v.x *= lac;\n"
"       cp *= pers;\n"
"   }\n"
"   return value;\n"
"}\n";

constexpr std::string_view perlin_value_point_2D =
"float perlin_value_point_2D(vec2f v, global float* randoms, global int* generator_defaults, global float* config_f, global int* config_i)\n"
"{\n"
"   float freq = config_f[0];\n"
"   float lac = config_f[1];\n"
"   float pers = config_f[2];\n"
"   int octaveCount = config_i[0];\n"
"   int _seed = config_i[1];\n"
"   float value = 0.0f;\n"
"   float cp = 1.0f;\n"
"   v.x *= freq;\n"
"   v.y *= freq;\n"
"   for (int i = 0; i < octaveCount; i++)\n"
"   {\n"
"       vec2f nv;\n"
"       nv.x = make_int32_range(v.x);\n"
"       nv.y = make_int32_range(v.y);\n"
"       float seed = (_seed + i) & 0xffffffff;\n"
"       float signal = gradient_coherent_noise_2D(nv, seed, randoms, generator_defaults, config_i);\n"
"       value += signal * cp;\n"
"       v.x *= lac;\n"
"       v.y *= lac;\n"
"       cp *= pers;\n"
"   }\n"
"   return value;\n"
"}\n";

constexpr std::string_view perlin_value_point_3D =
"float perlin_value_point_3D(vec3f v, global float* randoms, global int* generator_defaults, global float* config_f, global int* config_i)\n"
"{\n"
"   float freq = config_f[0];\n"
"   float lac = config_f[1];\n"
"   float pers = config_f[2];\n"
"   int octaveCount = config_i[0];\n"
"   int _seed = config_i[1];\n"
"   float value = 0.0f;\n"
"   float cp = 1.0f;\n"
"   v.x *= freq;\n"
"   v.y *= freq;\n"
"   v.z *= freq;\n"
"   for (int i = 0; i < octaveCount; i++)\n"
"   {\n"
"       vec3f nv;\n"
"       nv.x = make_int32_range(v.x);\n"
"       nv.y = make_int32_range(v.y);\n"
"       nv.z = make_int32_range(v.z);\n"
"       float seed = (_seed + i) & 0xffffffff;\n"
"       float signal = gradient_coherent_noise_3D(nv, seed, randoms, generator_defaults, config_i);\n"
"       value += signal * cp;\n"
"       v.x *= lac;\n"
"       v.y *= lac;\n"
"       v.z *= lac;\n"
"       cp *= pers;\n"
"   }\n"
"   return value;\n"
"}\n";

constexpr std::string_view perlin_value_point_4D =
"float perlin_value_point_4D(vec4f v, global float* randoms, global int* generator_defaults, global float* config_f, global int* config_i)\n"
"{\n"
"   float freq = config_f[0];\n"
"   float lac = config_f[1];\n"
"   float pers = config_f[2];\n"
"   int octaveCount = config_i[0];\n"
"   int _seed = config_i[1];\n"
"   float value = 0.0f;\n"
"   float cp = 1.0f;\n"
"   v.x *= freq;\n"
"   v.y *= freq;\n"
"   v.z *= freq;\n"
"   v.w *= freq;\n"
"   for (int i = 0; i < octaveCount; i++)\n"
"   {\n"
"       vec4f nv;\n"
"       nv.x = make_int32_range(v.x);\n"
"       nv.y = make_int32_range(v.y);\n"
"       nv.z = make_int32_range(v.z);\n"
"       nv.w = make_int32_range(v.w);\n"
"       float seed = (_seed + i) & 0xffffffff;\n"
"       float signal = gradient_coherent_noise_4D(nv, seed, randoms, generator_defaults, config_i);\n"
"       value += signal * cp;\n"
"       v.x *= lac;\n"
"       v.y *= lac;\n"
"       v.z *= lac;\n"
"       v.w *= lac;\n"
"       cp *= pers;\n"
"   }\n"
"   return value;\n"
"}\n";

constexpr std::string_view perlin_points_1D =
"void kernel generate_perlin_points_1D(\n"
"   global float* results,\n"
"   global vec1f* points,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   results[n] = perlin_value_point_1D(points[n], randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_ranges_1D =
"void kernel generate_perlin_ranges_1D(\n"
"   global float* results,\n"
"   range1f range, precision1 precision,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   vec1i vz;\n"
"   vz.x = n%precision.x;\n"
"   vec1f vr;\n"
"   vr.x = vz.x/(float)precision.x;\n"
"   vr.x = interpolate_linear(range.x.x, range.x.y, vr.x);\n"
"   results[n] = perlin_value_point_1D(vr, randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_points_2D =
"void kernel generate_perlin_points_2D(\n"
"   global float* results,\n"
"   global vec2f* points,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   results[n] = perlin_value_point_2D(points[n], randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_ranges_2D =
"void kernel generate_perlin_ranges_2D(\n"
"   global float* results,\n"
"   range2f range, precision2 precision,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   vec2i vz;\n"
"   vz.x = n%precision.x;\n"
"   vz.y = n/precision.x%precision.y;\n"
"   vec2f vr;\n"
"   vr.x = vz.x/(float)precision.x;\n"
"   vr.y = vz.y/(float)precision.y;\n"
"   vr.x = interpolate_linear(range.x.x, range.x.y, vr.x);\n"
"   vr.y = interpolate_linear(range.y.x, range.y.y, vr.y);\n"
"   results[n] = perlin_value_point_2D(vr, randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_points_3D =
"void kernel generate_perlin_points_3D(\n"
"   global float* results,\n"
"   global vec3f* points,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   results[n] = perlin_value_point_3D(points[n], randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_ranges_3D =
"void kernel generate_perlin_ranges_3D(\n"
"   global float* results,\n"
"   range3f range, precision3 precision,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   vec3i vz;\n"
"   vz.x = n%precision.x;\n"
"   vz.y = n/precision.x%precision.y;\n"
"   vz.z = n/precision.x/precision.y%precision.z;\n"
"   vec3f vr;\n"
"   vr.x = vz.x/(float)precision.x;\n"
"   vr.y = vz.y/(float)precision.y;\n"
"   vr.z = vz.z/(float)precision.z;\n"
"   vr.x = interpolate_linear(range.x.x, range.x.y, vr.x);\n"
"   vr.y = interpolate_linear(range.y.x, range.y.y, vr.y);\n"
"   vr.z = interpolate_linear(range.z.x, range.z.y, vr.z);\n"
"   results[n] = perlin_value_point_3D(vr, randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_points_4D =
"void kernel generate_perlin_points_4D(\n"
"   global float* results,\n"
"   global vec4f* points,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   results[n] = perlin_value_point_4D(points[n], randoms, generator_defaults, config_f, config_i);\n"
"}\n";

constexpr std::string_view perlin_ranges_4D =
"void kernel generate_perlin_ranges_4D(\n"
"   global float* results,\n"
"   range4f range, precision4 precision,\n"
"   global float* randoms, global int* generator_defaults,\n"
"   global float* config_f, global int* config_i\n"
")\n"
"{\n"
"   int n = get_global_id(0);\n"
"   vec4i vz;\n"
"   vz.x = n%precision.x;\n"
"   vz.y = n/precision.x%precision.y;\n"
"   vz.z = n/precision.x/precision.y%precision.z;\n"
"   vz.w = n/precision.x/precision.y/precision.z%precision.w;\n"
"   vec4f vr;\n"
"   vr.x = vz.x/(float)precision.x;\n"
"   vr.y = vz.y/(float)precision.y;\n"
"   vr.z = vz.z/(float)precision.z;\n"
"   vr.w = vz.w/(float)precision.w;\n"
"   vr.x = interpolate_linear(range.x.x, range.x.y, vr.x);\n"
"   vr.y = interpolate_linear(range.y.x, range.y.y, vr.y);\n"
"   vr.z = interpolate_linear(range.z.x, range.z.y, vr.z);\n"
"   vr.w = interpolate_linear(range.w.x, range.w.y, vr.w);\n"
"   results[n] = perlin_value_point_4D(vr, randoms, generator_defaults, config_f, config_i);\n"
"}\n";